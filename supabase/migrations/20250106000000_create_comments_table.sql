-- Create comments table
CREATE TABLE "public"."comments" (
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    "post_url" text NOT NULL,
    "post_title" text NOT NULL,
    "user_id" uuid,
    "name" text NOT NULL,
    "email" text,
    "avatar" text,
    "comment" text NOT NULL,
    "approved" boolean NOT NULL DEFAULT false,
    "created_at" timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
    "updated_at" timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),
    CONSTRAINT "comments_pkey" PRIMARY KEY ("id")
);

-- Create index for faster lookups
CREATE INDEX "comments_post_url_idx" ON "public"."comments" ("post_url");
CREATE INDEX "comments_created_at_idx" ON "public"."comments" ("created_at");
CREATE INDEX "comments_approved_idx" ON "public"."comments" ("approved");

-- Add comments
COMMENT ON TABLE "public"."comments" IS 'Blog post comments from users and guests';
COMMENT ON COLUMN "public"."comments"."post_url" IS 'URL of the blog post this comment belongs to';
COMMENT ON COLUMN "public"."comments"."post_title" IS 'Title of the blog post for reference';
COMMENT ON COLUMN "public"."comments"."user_id" IS 'User ID if comment is from authenticated user (null for guests)';
COMMENT ON COLUMN "public"."comments"."name" IS 'Name of the commenter';
COMMENT ON COLUMN "public"."comments"."email" IS 'Email of the commenter (optional for guests)';
COMMENT ON COLUMN "public"."comments"."avatar" IS 'Avatar URL for the commenter';
COMMENT ON COLUMN "public"."comments"."comment" IS 'The actual comment content';
COMMENT ON COLUMN "public"."comments"."approved" IS 'Whether the comment has been approved for display';

-- Create trigger to update updated_at on changes
CREATE OR REPLACE FUNCTION update_comments_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_comments_updated_at_trigger
    BEFORE UPDATE ON "public"."comments"
    FOR EACH ROW
    EXECUTE FUNCTION update_comments_updated_at();

-- Enable RLS
ALTER TABLE "public"."comments" ENABLE ROW LEVEL SECURITY;

-- RLS Policies
-- Anyone can read approved comments
CREATE POLICY "Anyone can view approved comments"
ON "public"."comments"
AS PERMISSIVE
FOR SELECT
TO public
USING (approved = true);

-- Authenticated users can view their own comments (regardless of approval status)
CREATE POLICY "Users can view own comments"
ON "public"."comments"
AS PERMISSIVE
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

-- Anyone can insert comments (but they start as unapproved)
CREATE POLICY "Anyone can insert comments"
ON "public"."comments"
AS PERMISSIVE
FOR INSERT
TO public
WITH CHECK (approved = false);

-- Only authenticated users can update their own comments
CREATE POLICY "Users can update own comments"
ON "public"."comments"
AS PERMISSIVE
FOR UPDATE
TO authenticated
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Only authenticated users can delete their own comments
CREATE POLICY "Users can delete own comments"
ON "public"."comments"
AS PERMISSIVE
FOR DELETE
TO authenticated
USING (auth.uid() = user_id);

-- Admins can do everything (requires admin role check)
CREATE POLICY "Admins can manage all comments"
ON "public"."comments"
AS PERMISSIVE
FOR ALL
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM users 
        WHERE users.id = auth.uid() 
        AND users.role = 'admin'
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1 FROM users 
        WHERE users.id = auth.uid() 
        AND users.role = 'admin'
    )
);

-- Grant permissions
GRANT ALL ON "public"."comments" TO anon, authenticated, service_role;
GRANT USAGE ON SEQUENCE "public"."comments_id_seq" TO anon, authenticated, service_role; 